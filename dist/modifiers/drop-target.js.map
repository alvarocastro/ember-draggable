{"version":3,"file":"drop-target.js","sources":["../../src/modifiers/drop-target.js"],"sourcesContent":["import { modifier } from 'ember-modifier';\nimport { dropTargetForElements } from '@atlaskit/pragmatic-drag-and-drop/element/adapter';\nimport {\n  attachClosestEdge,\n  extractClosestEdge,\n} from '@atlaskit/pragmatic-drag-and-drop-hitbox/closest-edge';\nimport {\n  attachInstruction,\n  extractInstruction,\n} from '@atlaskit/pragmatic-drag-and-drop-hitbox/tree-item';\n\nexport const CLASS = {\n  DRAGGING: 'is-dragging',\n  DROP_TARGET_ITEM: 'drop-target-item',\n};\n\nexport const DIRECTION = {\n  VERTICAL: 'vertical',\n  HORIZONTAL: 'horizontal',\n};\nexport const DIRECTION_EDGES = {\n  [DIRECTION.VERTICAL]: ['top', 'bottom'],\n  [DIRECTION.HORIZONTAL]: ['left', 'right'],\n};\n\n/**\n * Util function to normalize the drag and drop event data.\n * @param {Object} event Drag and drop event.\n * @return {Object}\n */\nexport const prepareDataForCallback = function (event) {\n  const source = {\n    data: event.source.data.data,\n    group: event.source.data.group,\n  };\n  const target = event.self\n    ? {\n        data: event.self.data.data,\n        group: event.self.data.group,\n        edge: extractClosestEdge(event.self.data),\n        tree: extractInstruction(event.self.data).type,\n      }\n    : {};\n\n  return {\n    source,\n    target,\n    event,\n  };\n};\n\n/**\n * Util function that computes the depth of a nested drop target relative to a\n * dragged item.\n * @param {Object} event Drag and drop event.\n * @return {Number}\n */\nexport const getNestedDepth = function (event) {\n  const targets = event.location.current.dropTargets;\n  const element = event.self.element;\n\n  return targets.indexOf(targets.find((target) => target.element === element));\n};\n\n/**\n * Modifier to define a drop target for draggable items.\n * @param {HTMLElement} element Target DOM element.\n * @param {any} options.data Data to associate with the drop target.\n * @param {String} options.group This drop target belongs to.\n * @param {Array} [options.accepts] Array of types this target accepts.\n * @param {String} [options.direction=\"vertical\"] Shortcut to define presets of `allowedEdges`. Options: \"horizontal\", \"vertical\".\n * @param {Array} [options.allowedEdges] Array of allowed edges to detect on drop. Options: \"top\", \"bottom\", \"left\", \"right\".\n * @param {Boolean} [options.allowDropOnItself=false] Allow an element to drop on itself if it's both a draggable item and drop target.\n * @param {Boolean} [options.allowDropOnChildren=false] Allow the target to receive drops from a parent draggable (this option is valid for nested targets)\n * @param {Boolean} [disabled] Prevents the element to both be dragged and receive drops.\n * @param {String} [options.isOnTargetClass] Class added to the element when an item is dragged over.\n * @param {Function} [options.canDrop] Callback used to conditionally allow drops.\n * @param {Function} [options.onDrop] Callback fired when an item is dropped.\n * @param {Function} [options.onHover] Callback fired when an item is dragged over.\n * @param {Function} [option.onDragEnter] Callback fired when a dragged item enters this target.\n * @param {Function} [option.onDragLeave] Callback fired when a dragged item leaves this target.\n */\nexport default modifier(\n  function dropTarget(\n    element,\n    positional,\n    {\n      data,\n      group,\n      accepts = [],\n      direction = DIRECTION.VERTICAL, // 'vertical' | 'horizontal'\n      allowedEdges, // [ 'top', 'bottom', 'left', 'right' ]\n      allowDropOnItself = false,\n      allowDropOnChildren = false,\n      disabled = false,\n      isOnTargetClass = CLASS.DROP_TARGET_ITEM,\n      canDrop = (payload, canDrop) => canDrop,\n      onDrop = () => {},\n      onHover = () => {},\n      onDragEnter = () => {},\n      onDragLeave = () => {},\n    } = {},\n  ) {\n    return dropTargetForElements({\n      element: element,\n      canDrop: (event) => {\n        const {\n          source: { data, element: draggedElement },\n        } = event;\n        let result = true;\n\n        if (disabled) {\n          result = false;\n        } else if (!allowDropOnChildren && draggedElement.contains(element)) {\n          result = false;\n        } else if (!allowDropOnItself && element === draggedElement) {\n          result = false;\n        } else {\n          result = accepts.length\n            ? accepts.includes(data.group)\n            : data.group === group;\n        }\n        return canDrop(prepareDataForCallback(event), result);\n      },\n      getData: ({ input, element }) => {\n        let payload = { data, group };\n\n        payload = attachClosestEdge(payload, {\n          input,\n          element,\n          allowedEdges: allowedEdges ?? DIRECTION_EDGES[direction],\n        });\n\n        payload = attachInstruction(payload, {\n          input,\n          element,\n          currentLevel: 2,\n          indentPerLevel: 20,\n          mode: 'standard',\n        });\n\n        return payload;\n      },\n      onDragEnter: (event) => {\n        element.classList.add(isOnTargetClass);\n        onDragEnter(prepareDataForCallback(event));\n      },\n      onDragLeave: (event) => {\n        element.classList.remove(isOnTargetClass);\n        delete element.dataset.dropEdge;\n        delete element.dataset.treeInstruction;\n        onDragLeave(prepareDataForCallback(event));\n      },\n      onDrag: (event) => {\n        const depth = getNestedDepth(event);\n        if (depth > 0) {\n          element.classList.remove(isOnTargetClass);\n          delete element.dataset.dropEdge;\n          delete element.dataset.treeInstruction;\n          return;\n        }\n        element.classList.add(isOnTargetClass);\n        element.dataset.dropEdge = extractClosestEdge(event.self.data);\n        element.dataset.treeInstruction = extractInstruction(\n          event.self.data,\n        ).type;\n        onHover(prepareDataForCallback(event));\n      },\n      onDrop: (event) => {\n        element.classList.remove(isOnTargetClass);\n        delete element.dataset.dropEdge;\n        delete element.dataset.treeInstruction;\n\n        if (getNestedDepth(event) === 0) {\n          onDrop(prepareDataForCallback(event));\n        }\n      },\n    });\n  },\n  { eager: false },\n);\n"],"names":["CLASS","DRAGGING","DROP_TARGET_ITEM","DIRECTION","VERTICAL","HORIZONTAL","DIRECTION_EDGES","prepareDataForCallback","event","source","data","group","target","self","edge","extractClosestEdge","tree","extractInstruction","type","getNestedDepth","targets","location","current","dropTargets","element","indexOf","find","modifier","dropTarget","positional","accepts","direction","allowedEdges","allowDropOnItself","allowDropOnChildren","disabled","isOnTargetClass","canDrop","payload","onDrop","onHover","onDragEnter","onDragLeave","dropTargetForElements","draggedElement","result","contains","length","includes","getData","input","attachClosestEdge","attachInstruction","currentLevel","indentPerLevel","mode","classList","add","remove","dataset","dropEdge","treeInstruction","onDrag","depth","eager"],"mappings":"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"}